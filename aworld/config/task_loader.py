# coding: utf-8
# Copyright (c) 2025 inclusionAI.
"""
Task YAML Loader: Load Task instances from YAML configuration files.

This module provides utilities to:
1. Parse Task YAML files generated by MetaAgent
2. Instantiate agents of different types (builtin/skill/predefined)
3. Build swarm topology using swarm_builder
4. Create executable Task instances

Supported agent types:
- builtin: Inline configuration (uses agent_loader.load_agents_from_dict)
- skill: Build from Agentic Skill (skills/{skill_name}/skill.md)
- predefined: Reference to external agent instance
"""

import os
from pathlib import Path
from typing import Dict, List, Any, Optional

import yaml

from aworld.agents.llm_agent import Agent
from aworld.config import AgentConfig, TaskConfig
from aworld.config.agent_loader import load_agents_from_dict
from aworld.core.agent.base import BaseAgent
from aworld.core.agent.swarm import Swarm
from aworld.core.agent.swarm_builder import build_swarm_from_dict
from aworld.core.context.amni.config import AmniContextConfig
from aworld.core.task import Task
from aworld.logs.util import logger
from aworld.utils.common import replace_env_variables


def _load_yaml(path: str) -> Dict[str, Any]:
    """Load and parse YAML file with environment variable substitution."""
    if not os.path.exists(path):
        raise FileNotFoundError(f"Task YAML file not found: {path}")
    
    with open(path, "r", encoding="utf-8") as f:
        try:
            data = yaml.safe_load(f) or {}
        except yaml.YAMLError as e:
            raise ValueError(f"Failed to parse YAML file: {e}")
    
    if not isinstance(data, dict):
        raise ValueError("Task YAML root must be a dictionary")
    
    # Replace ${ENV_VAR} placeholders
    data = replace_env_variables(data)
    
    return data


async def load_task_from_yaml(
    yaml_path: str,
    *,
    available_agents: Dict[str, BaseAgent] = None,
    skills_path: Optional[Path] = None,
    context_config: Optional[AmniContextConfig] = None,
    **task_overrides
) -> Task:
    """
    Load Task instance from YAML configuration.
    
    Args:
        yaml_path: Path to Task YAML file (generated by MetaAgent)
        available_agents: Dict of predefined agents for type='predefined' {agent_id: agent_instance}
        skills_path: Path to skills directory (required for type='skill' agents)
        context_config: Context configuration for the task
        **task_overrides: Override task-level configs (e.g., timeout, session_id, task_id)
    
    Returns:
        Task instance ready to execute via Runners.run_task()
    
    Raises:
        ValueError: If YAML is invalid or required resources are missing
        FileNotFoundError: If YAML file or skill files don't exist
    
    Example:
        >>> task = await load_task_from_yaml(
        ...     "task_plan.yaml",
        ...     available_agents={"search_agent": my_search_agent},
        ...     skills_path=Path("./skills")
        ... )
        >>> results = await Runners.run_task(task)
    """
    # 1. Parse YAML
    logger.info(f"ðŸ“„ Loading Task YAML from: {yaml_path}")
    data = _load_yaml(yaml_path)
    
    # 2. Instantiate agents
    logger.info("ðŸ”§ Instantiating agents...")
    agents_dict = await _load_agents(
        data.get("agents", []),
        available_agents=available_agents,
        skills_path=skills_path,
        global_mcp_config=data.get("mcp_config")
    )
    logger.info(f"âœ… Loaded {len(agents_dict)} agents: {list(agents_dict.keys())}")
    
    # 3. Build swarm
    logger.info("ðŸ•¸ï¸ Building swarm...")
    swarm = _build_swarm(data.get("swarm", {}), agents_dict)
    logger.info(f"âœ… Built swarm: type={swarm.build_type}, agents={len(swarm.agents)}")
    
    # 4. Create Task
    task_meta = data.get("task", {})
    task_config_dict = data.get("task_config", {})
    task_config = TaskConfig(**task_config_dict) if task_config_dict else None
    
    task = Task(
        input=task_overrides.get("input") or task_meta.get("query"),
        session_id=task_overrides.get("session_id") or task_meta.get("session_id"),
        id=task_overrides.get("task_id") or task_meta.get("task_id"),
        swarm=swarm,
        tool_names=data.get("tools", []),
        context_config=context_config,
        conf=task_config,
        **{k: v for k, v in task_overrides.items() if k not in ["input", "session_id", "task_id"]}
    )
    
    logger.info(f"âœ… Task created: id={task.id}, session={task.session_id}")
    return task


async def _load_agents(
    agents_config: List[Dict[str, Any]],
    available_agents: Optional[Dict[str, BaseAgent]],
    skills_path: Optional[Path],
    global_mcp_config: Optional[Dict[str, Any]]
) -> Dict[str, BaseAgent]:
    """
    Load and instantiate agents based on type.
    
    Args:
        agents_config: List of agent definitions from YAML
        available_agents: Dict of predefined agents
        skills_path: Path to skills directory
        global_mcp_config: Global MCP configuration
    
    Returns:
        Dict mapping agent_id to Agent instance
    
    Raises:
        ValueError: If agent is missing or configuration is invalid
    """
    from aworld.utils.skill_loader import collect_skill_docs
    
    agents_dict = {}
    available_agents = available_agents or {}
    
    for agent_def in agents_config:
        if not isinstance(agent_def, dict):
            raise ValueError(f"Agent definition must be a dictionary, got: {type(agent_def)}")
        
        agent_id = agent_def.get("id")
        if not agent_id:
            raise ValueError("Each agent must have an 'id' field")
        
        agent_type = agent_def.get("type", "builtin")
        
        try:
            if agent_type == "builtin":
                agent = await _load_builtin_agent(agent_id, agent_def, global_mcp_config)
            
            elif agent_type == "skill":
                agent = await _load_skill_agent(agent_id, agent_def, skills_path, global_mcp_config)
            
            elif agent_type == "predefined":
                agent = _load_predefined_agent(agent_id, available_agents)
            
            else:
                raise ValueError(f"Unknown agent type: {agent_type}")
            
            agents_dict[agent_id] = agent
            logger.debug(f"  âœ“ Loaded agent '{agent_id}' (type={agent_type})")
        
        except Exception as e:
            logger.error(f"  âœ— Failed to load agent '{agent_id}': {e}")
            raise
    
    return agents_dict


async def _load_builtin_agent(
    agent_id: str,
    agent_def: Dict[str, Any],
    global_mcp_config: Optional[Dict[str, Any]]
) -> BaseAgent:
    """
    Load builtin agent using agent_loader.load_agents_from_dict.
    
    This reuses existing agent loading logic for consistency.
    """
    # Transform to agent_loader format: {agent_id: {...config...}}
    builtin_dict = {agent_id: {
        "system_prompt": agent_def.get("system_prompt"),
        "desc": agent_def.get("desc", ""),
        "config": agent_def.get("config", {}),
        "mcp_servers": agent_def.get("mcp_servers", []),
        "mcp_config": _merge_mcp_configs(
            global_mcp_config, 
            agent_def.get("mcp_config")
        )
    }}
    
    # Remove None values
    builtin_dict[agent_id] = {k: v for k, v in builtin_dict[agent_id].items() if v is not None}
    
    loaded = load_agents_from_dict(builtin_dict)
    return loaded[agent_id]


async def _load_skill_agent(
    agent_id: str,
    agent_def: Dict[str, Any],
    skills_path: Optional[Path],
    global_mcp_config: Optional[Dict[str, Any]]
) -> BaseAgent:
    """
    Load agent from Agentic Skill (skill.md with type: agent).
    
    Raises:
        ValueError: If skill not found, not Agentic Skill, or skills_path missing
    """
    from aworld.utils.skill_loader import collect_skill_docs
    
    skill_name = agent_def.get("skill_name")
    if not skill_name:
        raise ValueError(f"missing agent {agent_id}: 'skill_name' field is required for agent type 'skill'")
    
    if not skills_path:
        raise ValueError(f"missing agent {agent_id}: skills_path required for agent type 'skill'")
    
    # Check if skills_path exists
    if not skills_path.exists():
        raise ValueError(f"missing agent {agent_id}: skills_path does not exist: {skills_path}")
    
    # Load skills
    try:
        skills_info = collect_skill_docs(skills_path)
    except Exception as e:
        raise ValueError(f"missing agent {agent_id}: failed to load skills from {skills_path}: {e}")
    
    if skill_name not in skills_info:
        available_skills = ', '.join(skills_info.keys()) if skills_info else 'none'
        raise ValueError(
            f"missing agent {agent_id}: Skill '{skill_name}' not found in {skills_path}. "
            f"Available skills: {available_skills}"
        )
    
    skill = skills_info[skill_name]
    
    # Verify it's an Agentic Skill
    if skill.get("type") != "agent":
        raise ValueError(
            f"missing agent {agent_id}: Skill '{skill_name}' is not an Agentic Skill "
            f"(type='{skill.get('type')}', expected type='agent')"
        )
    
    # Build Agent from skill (consistent with skill_service logic)
    agent_config_dict = agent_def.get("config", {})
    
    # If no llm_config provided, use environment variables
    if "llm_config" not in agent_config_dict:
        agent_config_dict["llm_config"] = {
            "llm_model_name": os.getenv("LLM_MODEL_NAME"),
            "llm_provider": os.getenv("LLM_PROVIDER"),
            "llm_api_key": os.getenv("LLM_API_KEY"),
            "llm_base_url": os.getenv("LLM_BASE_URL"),
        }
    
    agent_config = AgentConfig(**agent_config_dict) if agent_config_dict else AgentConfig()
    
    agent = Agent(
        name=agent_id,
        desc=skill.get("description", ""),
        conf=agent_config,
        system_prompt=skill.get("usage", ""),
        mcp_servers=list(skill.get("tool_list", {}).keys()),
        mcp_config=_merge_mcp_configs(
            global_mcp_config, 
            agent_def.get("mcp_config")
        )
    )
    
    return agent


def _load_predefined_agent(
    agent_id: str,
    available_agents: Dict[str, BaseAgent]
) -> BaseAgent:
    """
    Load predefined agent from available_agents dict.
    
    Raises:
        ValueError: If agent not found in available_agents
    """
    if agent_id not in available_agents:
        available = ', '.join(available_agents.keys()) if available_agents else 'none'
        raise ValueError(
            f"missing agent {agent_id}: agent not found in available_agents. "
            f"Available predefined agents: {available}"
        )
    
    return available_agents[agent_id]


def _build_swarm(swarm_config: Dict[str, Any], agents_dict: Dict[str, BaseAgent]) -> Swarm:
    """
    Build Swarm from config using swarm_builder.
    
    Args:
        swarm_config: Swarm configuration from YAML
        agents_dict: Dict of instantiated agents
    
    Returns:
        Swarm instance
    
    Raises:
        ValueError: If swarm configuration is invalid
    """
    if not swarm_config:
        raise ValueError("Task YAML must contain 'swarm' section")
    
    # Wrap in format expected by swarm_builder
    config = {"swarm": swarm_config}
    
    try:
        swarm = build_swarm_from_dict(config, agents_dict)
        return swarm
    except Exception as e:
        raise ValueError(f"Failed to build swarm: {e}")


def _merge_mcp_configs(
    global_config: Optional[Dict[str, Any]], 
    agent_config: Optional[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Merge global and agent-level MCP configs.
    
    Agent-level config takes precedence over global config.
    """
    if not global_config:
        return agent_config or {}
    if not agent_config:
        return global_config
    
    # Deep merge mcpServers
    merged = {"mcpServers": {}}
    merged["mcpServers"].update(global_config.get("mcpServers", {}))
    merged["mcpServers"].update(agent_config.get("mcpServers", {}))
    
    return merged
